(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{701:function(a,t,v){"use strict";v.r(t);var r=v(8),s=Object(r.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("p",[a._v("本章基于Java8详细介绍Java虚拟机。")]),a._v(" "),v("p",[a._v("为什么要学习JVM？")]),a._v(" "),v("ul",[v("li",[a._v("面试需要")]),a._v(" "),v("li",[a._v("中高级程序员必备技能")]),a._v(" "),v("li",[a._v("追求极客精神"),v("br")])]),a._v(" "),v("h2",{attrs:{id:"jvm架构模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jvm架构模型"}},[a._v("#")]),a._v(" JVM架构模型")]),a._v(" "),v("p",[a._v("Java编译器输入的指令流基本上是以下两种：")]),a._v(" "),v("ul",[v("li",[a._v("基于栈的指令集架构\n"),v("ul",[v("li",[a._v("设计和实现更简单，适用于资源受限的系统")]),a._v(" "),v("li",[a._v("避开了寄存器的分配难题，使用零地址指令方式分配")]),a._v(" "),v("li",[a._v("指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现")]),a._v(" "),v("li",[a._v("不需要硬件支持，可移植性更好，更好的实现跨平台")])])]),a._v(" "),v("li",[a._v("基于寄存器的指令架构\n"),v("ul",[v("li",[a._v("典型应用是x86的二进制指令集；比如传统的PC和Android的Davlik虚拟机")]),a._v(" "),v("li",[a._v("指令集架构则完全依赖硬件，可移植性差")]),a._v(" "),v("li",[a._v("性能优秀和执行更高效")]),a._v(" "),v("li",[a._v("花费更少的指令完成一项操作")]),a._v(" "),v("li",[a._v("在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主")])])])]),a._v(" "),v("h2",{attrs:{id:"jvm生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jvm生命周期"}},[a._v("#")]),a._v(" JVM生命周期")]),a._v(" "),v("ul",[v("li",[a._v("虚拟机的启动"),v("br"),a._v("\n虚拟机的启动是通过引导类加载器(bootstrap class loader)创建一个初始类来完成，这个类由虚拟机的具体实现指定的")]),a._v(" "),v("li",[a._v("虚拟机的执行\n"),v("ul",[v("li",[a._v("一个运行的虚拟机的Java虚拟机有着清晰的任务：执行Java程序")]),a._v(" "),v("li",[a._v("程序开始执行时它才执行，程序结束时他就停止")]),a._v(" "),v("li",[a._v("执行一个所谓的Java程序，真真正正在执行的是一个叫做Java虚拟机的进程")])])]),a._v(" "),v("li",[a._v("虚拟机的退出\n"),v("ul",[v("li",[a._v("程序正常执行结束")]),a._v(" "),v("li",[a._v("程序在执行过程中遇到了异常或者错误而异常终止")])])])]),a._v(" "),v("h2",{attrs:{id:"类加载子系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类加载子系统"}},[a._v("#")]),a._v(" 类加载子系统")]),a._v(" "),v("h2",{attrs:{id:"运行时数据区概述及线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#运行时数据区概述及线程"}},[a._v("#")]),a._v(" 运行时数据区概述及线程")]),a._v(" "),v("h2",{attrs:{id:"程序计数器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器"}},[a._v("#")]),a._v(" 程序计数器")]),a._v(" "),v("h2",{attrs:{id:"虚拟机栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机栈"}},[a._v("#")]),a._v(" 虚拟机栈")]),a._v(" "),v("h2",{attrs:{id:"本地方法接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#本地方法接口"}},[a._v("#")]),a._v(" 本地方法接口")]),a._v(" "),v("h2",{attrs:{id:"本地方法栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈"}},[a._v("#")]),a._v(" 本地方法栈")]),a._v(" "),v("h2",{attrs:{id:"堆"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[a._v("#")]),a._v(" 堆")]),a._v(" "),v("h2",{attrs:{id:"方法区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[a._v("#")]),a._v(" 方法区")]),a._v(" "),v("h2",{attrs:{id:"直接内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#直接内存"}},[a._v("#")]),a._v(" 直接内存")]),a._v(" "),v("h2",{attrs:{id:"执行引擎"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#执行引擎"}},[a._v("#")]),a._v(" 执行引擎")]),a._v(" "),v("h2",{attrs:{id:"stringtabel"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#stringtabel"}},[a._v("#")]),a._v(" StringTabel")]),a._v(" "),v("h2",{attrs:{id:"垃圾回收概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收概述"}},[a._v("#")]),a._v(" 垃圾回收概述")]),a._v(" "),v("h2",{attrs:{id:"垃圾回收相关算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收相关算法"}},[a._v("#")]),a._v(" 垃圾回收相关算法")]),a._v(" "),v("h2",{attrs:{id:"垃圾回收相关概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收相关概念"}},[a._v("#")]),a._v(" 垃圾回收相关概念")]),a._v(" "),v("h2",{attrs:{id:"垃圾回收器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器"}},[a._v("#")]),a._v(" 垃圾回收器")])])}),[],!1,null,null,null);t.default=s.exports}}]);