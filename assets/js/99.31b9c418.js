(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{696:function(a,s,l){"use strict";l.r(s);var e=l(8),v=Object(e.a)({},(function(){var a=this,s=a.$createElement,l=a._self._c||s;return l("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[l("h1",{attrs:{id:"java"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#java"}},[a._v("#")]),a._v(" Java")]),a._v(" "),l("ul",[l("li",[a._v("面向对象编程")]),a._v(" "),l("li",[a._v("容器\n"),l("ul",[l("li",[a._v("Map")]),a._v(" "),l("li",[a._v("List")]),a._v(" "),l("li",[a._v("Set")])])]),a._v(" "),l("li",[a._v("JVM内存模型")]),a._v(" "),l("li",[a._v("垃圾回收算法")]),a._v(" "),l("li",[a._v("类加载过程")]),a._v(" "),l("li",[a._v("反射")]),a._v(" "),l("li",[a._v("多线程、线程池")]),a._v(" "),l("li",[a._v("进程、线程与进程关系区别")])]),a._v(" "),l("h1",{attrs:{id:"java-2"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#java-2"}},[a._v("#")]),a._v(" Java")]),a._v(" "),l("p",[a._v("面向对象编程")]),a._v(" "),l("ul",[l("li",[a._v("封装")])]),a._v(" "),l("div",{staticClass:"language- line-numbers-mode"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[a._v("把客观事物封装成抽象的类，\n并且类可以把自己的数据和方法给可信的类或者对象操作使用，\n对不可信的进行信息隐藏\n")])]),a._v(" "),l("div",{staticClass:"line-numbers-wrapper"},[l("span",{staticClass:"line-number"},[a._v("1")]),l("br"),l("span",{staticClass:"line-number"},[a._v("2")]),l("br"),l("span",{staticClass:"line-number"},[a._v("3")]),l("br")])]),l("ul",[l("li",[a._v("继承")])]),a._v(" "),l("div",{staticClass:"language- line-numbers-mode"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[a._v("指可以让某个类的对象获得另一个类型的对象的属性的方法\n实现方式一: 实现继承，直接使用父类的属性和方法而无需额外编码的能力\n实现方式二：接口继承，仅使用属性和方法的名称，但子类必须提供实现的能力\n")])]),a._v(" "),l("div",{staticClass:"line-numbers-wrapper"},[l("span",{staticClass:"line-number"},[a._v("1")]),l("br"),l("span",{staticClass:"line-number"},[a._v("2")]),l("br"),l("span",{staticClass:"line-number"},[a._v("3")]),l("br")])]),l("ul",[l("li",[a._v("多态")])]),a._v(" "),l("div",{staticClass:"language- line-numbers-mode"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[a._v("指一个类实例的相同方法在不同情形有不同表现形式\n多态机制使具有不同内部结构的对象可以共享相同的外部接口\n")])]),a._v(" "),l("div",{staticClass:"line-numbers-wrapper"},[l("span",{staticClass:"line-number"},[a._v("1")]),l("br"),l("span",{staticClass:"line-number"},[a._v("2")]),l("br")])]),l("p",[a._v("设计原则（SPR、OCP、LSP、DIP、ISP）")]),a._v(" "),l("ul",[l("li",[a._v("单一职责原则（SPR）")])]),a._v(" "),l("div",{staticClass:"language- line-numbers-mode"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[a._v("一个类功能要单一，不能包罗万象\n")])]),a._v(" "),l("div",{staticClass:"line-numbers-wrapper"},[l("span",{staticClass:"line-number"},[a._v("1")]),l("br")])]),l("ul",[l("li",[a._v("开放封闭原则（OCP）")])]),a._v(" "),l("div",{staticClass:"language- line-numbers-mode"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[a._v("一个模块在扩展性方面应该是开放的\n而在更改性方面是封闭的\n")])]),a._v(" "),l("div",{staticClass:"line-numbers-wrapper"},[l("span",{staticClass:"line-number"},[a._v("1")]),l("br"),l("span",{staticClass:"line-number"},[a._v("2")]),l("br")])]),l("ul",[l("li",[a._v("里氏替换原则（LSP）")])]),a._v(" "),l("div",{staticClass:"language- line-numbers-mode"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[a._v("子类应当可以替换父类\n并出现在父类能够出现的任何地方\n")])]),a._v(" "),l("div",{staticClass:"line-numbers-wrapper"},[l("span",{staticClass:"line-number"},[a._v("1")]),l("br"),l("span",{staticClass:"line-number"},[a._v("2")]),l("br")])]),l("ul",[l("li",[a._v("依赖倒置原则（DIP）")])]),a._v(" "),l("div",{staticClass:"language- line-numbers-mode"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[a._v("具体依赖抽象\n上次依赖下层\n")])]),a._v(" "),l("div",{staticClass:"line-numbers-wrapper"},[l("span",{staticClass:"line-number"},[a._v("1")]),l("br"),l("span",{staticClass:"line-number"},[a._v("2")]),l("br")])]),l("ul",[l("li",[a._v("接口分离原则（ISP）")])]),a._v(" "),l("div",{staticClass:"language- line-numbers-mode"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[a._v("模块间要通过抽象接口隔离开\n而不是通过具体的类强耦合起来\n")])]),a._v(" "),l("div",{staticClass:"line-numbers-wrapper"},[l("span",{staticClass:"line-number"},[a._v("1")]),l("br"),l("span",{staticClass:"line-number"},[a._v("2")]),l("br")])]),l("p",[a._v("容器：Map、List、Set")]),a._v(" "),l("ul",[l("li",[l("p",[a._v("Map（键值对存储方式）")]),a._v(" "),l("ul",[l("li",[a._v("HashMap\n"),l("ul",[l("li",[a._v("key可以为Null，把Null当作key存储")])])]),a._v(" "),l("li",[a._v("HashTable")]),a._v(" "),l("li",[a._v("TreeMap")]),a._v(" "),l("li",[a._v("ConcurrentHashMap")]),a._v(" "),l("li",[a._v("LinkedHashMap")]),a._v(" "),l("li",[a._v("WeakHashMap")])])]),a._v(" "),l("li",[l("p",[a._v("List（侧重于顺序）")]),a._v(" "),l("ul",[l("li",[a._v("LinkedList\n"),l("ul",[l("li",[a._v("底层是由双向链表结构实现的，通过节点来存储下一个元素的位置")]),a._v(" "),l("li",[a._v("对集合中元素可以方便的增删，更适合用于大量修改")])])]),a._v(" "),l("li",[a._v("ArrayList\n"),l("ul",[l("li",[a._v("底层由数组实现，数组在内存中的存储顺序是连续的")]),a._v(" "),l("li",[a._v("对集合中的元素可以进行快速访问，更适合随即查询数据")])])]),a._v(" "),l("li",[a._v("Vector\n"),l("ul",[l("li",[a._v("Vector与ArrayList区别就是Vector是线程安全的集合")]),a._v(" "),l("li",[a._v("在需要线程安全而且对效率要求比较低的情况下使用")])])])])]),a._v(" "),l("li",[l("p",[a._v("Set（侧重于独一无二，不包含重复元素）")]),a._v(" "),l("ul",[l("li",[a._v("HashSet\n"),l("ul",[l("li",[a._v("侧重于快速访问")])])]),a._v(" "),l("li",[a._v("TreeSet\n"),l("ul",[l("li",[a._v("侧重于排序")])])]),a._v(" "),l("li",[a._v("LinkedHashSet\n"),l("ul",[l("li",[a._v("侧重于插入顺序")])])])])])]),a._v(" "),l("p",[a._v("JVM内存模型")]),a._v(" "),l("p",[a._v("垃圾回收算法")]),a._v(" "),l("p",[a._v("类加载过程")]),a._v(" "),l("p",[a._v("反射")]),a._v(" "),l("p",[a._v("多线程、线程池，进程、线程与进程关系区别")]),a._v(" "),l("p",[a._v("Java重要的基础类")]),a._v(" "),l("ul",[l("li",[a._v("Collections")]),a._v(" "),l("li",[a._v("CharSequence")]),a._v(" "),l("li",[a._v("Iterator集合的迭代器")])])])}),[],!1,null,null,null);s.default=v.exports}}]);