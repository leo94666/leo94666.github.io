(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{669:function(t,a,e){"use strict";e.r(a);var v=e(8),s=Object(v.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"netty"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#netty"}},[t._v("#")]),t._v(" Netty")]),t._v(" "),e("h2",{attrs:{id:"介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[t._v("#")]),t._v(" 介绍")]),t._v(" "),e("ul",[e("li",[t._v("Netty是由JBOSS提供的一个Java开源框架")]),t._v(" "),e("li",[t._v("Netty是一个异步的，基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络IO程序")]),t._v(" "),e("li",[t._v("Netty主要针对在TCP协议下，面向Clients端的高并发应用，或者peer-to-peer场景下的大量数据持续传输的应用")]),t._v(" "),e("li",[t._v("Netty本质上是一个NIO框架，适用于服务器通讯相关的多种应用场景")])]),t._v(" "),e("h2",{attrs:{id:"应用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),e("ul",[e("li",[t._v("互联网行业，Dubbo，RPC框架")]),t._v(" "),e("li",[t._v("游戏行业，手游、网络服务、地图服务器")]),t._v(" "),e("li",[t._v("大数据领域，Hadoop")])]),t._v(" "),e("h2",{attrs:{id:"i-o模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#i-o模型"}},[t._v("#")]),t._v(" I/O模型")]),t._v(" "),e("p",[t._v("Java支持3种网络编程模型")]),t._v(" "),e("ul",[e("li",[t._v("BIO: 同步并阻塞(blocking I/O)"),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("BIO适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，jdk1.4之前唯一的选择\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])])]),t._v(" "),e("li",[t._v("NIO: 同步非阻塞(non-blocking I/O)"),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("NIO适用于连接数目多且连接比较短(轻操作)的架构，如聊天服务器、弹幕系统、服务器间通讯，jdk1.4开始支持\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])])]),t._v(" "),e("li",[t._v("AIO: 异步非阻塞(Asynchronous I/O)"),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("AIO适用于连接数目多且连接比较长(重操作)的架构，如相册服务器、充分调用OS参与并发操作，jdk1.7开始支持\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])])])]),t._v(" "),e("h3",{attrs:{id:"bio-同步阻塞"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bio-同步阻塞"}},[t._v("#")]),t._v(" BIO(同步阻塞)")]),t._v(" "),e("ol",[e("li",[t._v("传统java io编程    相关代码在java.io")]),t._v(" "),e("li",[t._v("适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高")])]),t._v(" "),e("pre",[t._v("undefined")]),e("h4",{attrs:{id:"bio编程流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bio编程流程"}},[t._v("#")]),t._v(" BIO编程流程")]),t._v(" "),e("p",[t._v("1.服务端启动一个ServerSocket"),e("br"),t._v("\n2.客户端启动Socket对服务器进行通信，默认情况下服务器需要对每个客户建立一个线程与之通讯"),e("br"),t._v("\n3.客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待或者被拒绝"),e("br"),t._v("\n4.如果有响应，客户端线程会等待请求结束后，在继续执行")]),t._v(" "),e("h4",{attrs:{id:"bio弊端"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bio弊端"}},[t._v("#")]),t._v(" BIO弊端")]),t._v(" "),e("ul",[e("li",[t._v("每个请求都需要创建独立线程，与对应的客户端进行数据读写、业务处理")]),t._v(" "),e("li",[t._v("当并发量比较大时，需要创建大量线程来处理连接，系统资源占用比较大")]),t._v(" "),e("li",[t._v("连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在read操作上，造成线程资源浪费")])]),t._v(" "),e("h3",{attrs:{id:"nio-同步非阻塞"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nio-同步非阻塞"}},[t._v("#")]),t._v(" NIO(同步非阻塞)")]),t._v(" "),e("p",[t._v("相关代码带java.nio下，并对愿java.io包中的很多类进行改写")]),t._v(" "),e("p",[t._v("NIO是面向缓冲区、或者面向块的编程，数据读到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络")]),t._v(" "),e("p",[t._v("NIO可以做到一个线程来处理多个操作")]),t._v(" "),e("p",[t._v("tip: HTTP2.0使用了多路复用技术，做到了同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级")]),t._v(" "),e("h4",{attrs:{id:"nio三大核心"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nio三大核心"}},[t._v("#")]),t._v(" NIO三大核心")]),t._v(" "),e("ul",[e("li",[t._v("Channel(通道)")]),t._v(" "),e("li",[t._v("Buffer(缓冲区)")]),t._v(" "),e("li",[t._v("Seletor(选择器)")])]),t._v(" "),e("p",[e("strong",[t._v("关系")])]),t._v(" "),e("ul",[e("li",[t._v("每个channel都会对应一个buffer")]),t._v(" "),e("li",[t._v("selector对应一个线程，一个线程对应多个selector")]),t._v(" "),e("li",[t._v("Selector会根据不同的事件，在各个通道上切换")]),t._v(" "),e("li",[t._v("Buffer就是个内存块，底层是一个数组")]),t._v(" "),e("li",[t._v("数据的读写是通过Buffer，NIO的Buffer是可以读写，需要flip方法切换")]),t._v(" "),e("li",[t._v("channel是双向的，可以返回底层操作系统的情况，比如linux，底层的操作系统通道是双向的")])]),t._v(" "),e("pre",[t._v("undefined")]),e("p",[e("strong",[t._v("Buffer")])]),t._v(" "),e("p",[e("strong",[t._v("Channel")])]),t._v(" "),e("p",[e("strong",[t._v("Selector")])]),t._v(" "),e("p",[t._v("=======")])])}),[],!1,null,null,null);a.default=s.exports}}]);